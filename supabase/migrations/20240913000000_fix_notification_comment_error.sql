-- Step 1: Drop the old, incorrect notifications table and related types/functions if they exist.
-- This ensures a clean slate.
DROP TRIGGER IF EXISTS on_new_comment_send_notification ON public.post_comments;
DROP FUNCTION IF EXISTS public.send_comment_notification();
DROP TABLE IF EXISTS public.notifications;
DROP TYPE IF EXISTS public.notification_type;

-- Step 2: Create a new ENUM type for notification types for better data consistency.
CREATE TYPE public.notification_type AS ENUM (
  'new_follower',
  'new_comment',
  'new_like' -- Added for future use
);

-- Step 3: Create the 'notifications' table with the correct structure.
CREATE TABLE public.notifications (
    id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    actor_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    recipient_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
    type public.notification_type NOT NULL,
    is_read BOOLEAN DEFAULT FALSE NOT NULL,
    target_post_id BIGINT REFERENCES public.posts(id) ON DELETE CASCADE, -- This is the crucial column for post-related notifications
    target_id UUID, -- Kept for other potential UUID-based targets
    created_at TIMESTAMP WITH TIME ZONE DEFAULT timezone('utc'::text, now()) NOT NULL,
    CONSTRAINT notifications_recipient_id_check CHECK (recipient_id <> actor_id)
);

-- Add comments for clarity
COMMENT ON COLUMN public.notifications.actor_id IS 'The user who performed the action.';
COMMENT ON COLUMN public.notifications.recipient_id IS 'The user who receives the notification.';
COMMENT ON COLUMN public.notifications.type IS 'The type of notification (e.g., new_comment, new_follower).';
COMMENT ON COLUMN public.notifications.target_post_id IS 'The ID of the post that is the target of the notification (e.g., the post that was commented on).';
COMMENT ON COLUMN public.notifications.target_id IS 'A generic target ID for non-post related notifications (e.g., user ID for follows).';

-- Step 4: Recreate the database function to handle sending notifications for new comments.
CREATE OR REPLACE FUNCTION public.send_comment_notification()
RETURNS TRIGGER
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  post_owner_id UUID;
  post_id_val BIGINT;
BEGIN
  -- Get the owner of the post that was commented on
  SELECT user_id, id INTO post_owner_id, post_id_val
  FROM public.posts
  WHERE id = NEW.post_id;

  -- Only send a notification if the commenter is not the post owner
  IF NEW.user_id <> post_owner_id THEN
    INSERT INTO public.notifications (recipient_id, actor_id, type, target_post_id)
    VALUES (post_owner_id, NEW.user_id, 'new_comment', post_id_val);
  END IF;

  RETURN NEW;
END;
$$;

-- Step 5: Recreate the trigger on the 'post_comments' table.
CREATE TRIGGER on_new_comment_send_notification
  AFTER INSERT ON public.post_comments
  FOR EACH ROW
  EXECUTE FUNCTION public.send_comment_notification();
